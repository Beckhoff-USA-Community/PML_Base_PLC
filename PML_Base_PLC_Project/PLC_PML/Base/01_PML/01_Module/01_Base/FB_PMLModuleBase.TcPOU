<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_PMLModuleBase" Id="{b51128fe-fac6-441f-bd13-bfcb90049779}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ABSTRACT FB_PMLModuleBase IMPLEMENTS ITF_PMLModuleBase
VAR_INPUT
	iMasterDataStructure_Adder		: ITF_Tree_IndexBased;			//Interface for adding new children to the master machine tree data representation
END_VAR
VAR
	//ITF_PMLModuleBase internal property variables
	sAncestorIDs					: STRING;				//String concatenation of preceding parent IDs to prefix this module's ID
	bLogModeChanges 	: BOOL := TRUE; 		//Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)
	bLogStateChanges 	: BOOL := FALSE; 		//Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)
	nModuleID			: UDINT;					//Unique identifying number for the module
	sModuleName			: STRING;				//Human-readable module name for user-side messaging
	bEnabled			: BOOL := TRUE;			//Enables or disables the packml Machine of the module (prevents the module from going past idle)
	eModeCommand		: E_PMLUnitMode; 				//Current Commanded UnitMode of the module
	eStateCommand		: Tc3_PackML_V2.E_PMLCommand;
	eMode				: E_PMLUnitMode;		//Current UnitMode of the module
	eState				: Tc3_PackML_V2.E_PMLState;
	iMasterDataStructure_Adder : ITF_Tree_IndexBased;
	
	//Communication Variables
	stPMLModuleBaseHMI	: ST_PMLModuleBase_HMI;		//Handles status and control communications with the HMI
	stPMLModuleBaseVISU	: ST_PMLModuleBase_VISU;	//Handles status and control communications with Visualizations
	fbExternalControl	: FB_ModuleExternalCommandControl;	//Handles commands from HMI/VISUS ^^ kind of overlaps with the structures above - TODO: Improve

	//Administration and Configuration Variables
	bInitialized 					: BOOL;					//TRUE when initialization code of the object is complete
	sID_Name						: STRING;				//"Module XX - 'Module Name' " Alarm and message utility phrase based off of nMachine ID and sMachineName
	
	//State and Mode control blocks
	fbModeManager 					: PML_UnitModeManager; 	//Manages operating mode transitions and rules
	fbStateMachine 					: PML_StateMachine; 	//Manages PackML state transitions
	fbCustomModes 					: PML_UnitModeConfig;	//Used to define custom machine modes if desired

	//State and Mode Status and Command variables
	sState							: STRING; 				//String representation of the current state
	eLastState						: E_PMLState;			//Last cycle PackML state
	eLastStateCommand				: E_PMLCommand;			//Previous received PackML state command
	eLastMode		 				: DINT;					//Last PackML mode 
	eLastModeCommand 				: E_PMLUnitMode;					//Previous received PackML mode command
	bStateTasksComplete				: BOOL := FALSE;					//All tasks to be performed at this program level are complete
	bNoStateTasksToComplete			: BOOL := TRUE;					//Indicates whether this stateneeds to perform tasks other than commanding its children
	bSubModulesReady				: BOOL;					//All submodules have reached the commanded state
	
	//Alarming and Logging variables - Some may or may not be necessary depending on final alarm system implementation ----------------------------------------------
	//These are for the newer TMC Excel import style alarm system
	a_fbPMLAlarms					: ARRAY[1..48] OF FB_TcAlarm;	//Array of alarms for PackML state and mode changes that exist in any PackML enabled module
	a_fbBaseAlarms					: ARRAY[1..32] OF FB_TcAlarm;		//Array of alarms for general module Alarms				
	fbPMLStateLogger				: FB_PMLStateLogger;				//Logs PackML state changes
	fbPMLModeLogger					: FB_PMLModeLogger;					//Logs PackML Mode changes

	// Alarm handling
	bActiveAlarm					: BOOL;					//module has an active alarm		TODO: Implement			
	bGlobalSafetyStatus				: BOOL;
	//********************************************************************************************************************
	// Sub Module variables
	// Used mostly for EMs and Machines, but ok for CM. They are just null	
	a_ITF_PackMLBase				: ARRAY[1..MAX_NO_OF_SUBMODULES] OF ITF_PMLModuleBase;	
	// Array of the PML sub unit info array used by the statemachine
	a_stPMLSubUnitInfo				: ARRAY[1..MAX_NO_OF_SUBMODULES] OF ST_PMLSubUnitInfo;
	nNumberOfSubModules				: UDINT := 0;	//calculated number of instantiated sub modules
	// This is the information for each module's submodules.
	PMLSubUnitInfoRef				: ST_PMLSubUnitInfoRef;				// Reference to the subunit information, used by the state machine
	//********************************************************************************************************************
	
	//Component variables - Allow iterative control of child components (Mostly used with Control Modules, but usable anywhere)
	a_ITF_Components				: ARRAY[1..MAX_NO_OF_COMPONENTS] OF ITF_ComponentBase;
	nNumberOfComponents				: UDINT := 0;	//calculated number of instantiated components
	
	//Miscellaneous Variables
	nIndex				: UDINT;		//Generic iteration value
	nIndex					: UDINT;		//Generic iteration value
	a_sModeNames					: ARRAY[0..31] OF STRING;
	i: UDINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//*********************************************************
// !!!!! Code implementation only in CyclicLogic() method !!!!! 
//*********************************************************
]]></ST>
    </Implementation>
    <Folder Name="01_ITF_PMLModuleBase" Id="{7853c128-7150-499f-afd2-1cc47b02c7fb}">
      <Folder Name="01_Properties" Id="{3f6fcce0-20d1-42fa-8d51-cf636ece4a9f}">
        <Folder Name="01_Config" Id="{ea82163c-dcb7-40a8-a188-494f28a69630}" />
        <Folder Name="02_Control" Id="{0f49fae0-d86c-4069-99a8-907b07387580}" />
        <Folder Name="03_Status" Id="{84ded71b-93ac-410b-9a46-f376b2f39afb}" />
      </Folder>
      <Folder Name="02_Methods" Id="{a47a966b-0b31-4e95-a3f6-5bd2e7b2f305}" />
    </Folder>
    <Folder Name="Methods" Id="{2374c43a-8b69-4250-ac37-650855e4142c}">
      <Folder Name="01_TransitionStates" Id="{2813ee04-f5e3-4130-bb47-4373fa697726}" />
      <Folder Name="02_PrimaryStates" Id="{fdb26b20-d68a-43a5-9170-8c0cae9f966b}" />
    </Folder>
    <Method Name="Aborted" Id="{f4c80f4a-1f00-40f6-a791-318ec4b3278d}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Aborted
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Aborting" Id="{ff7d5dfb-dd97-4700-92b4-3318a8a33dc3}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Aborting]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send abort command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Abort;
END_FOR

// All subunits in requested state?
bSubModulesReady := TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Aborted);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="AncestorIDs" Id="{e9e1bc49-319c-49cf-ab24-edd60fccd3be}" FolderPath="01_ITF_PMLModuleBase\01_Properties\01_Config\">
      <Declaration><![CDATA[PROPERTY AncestorIDs : STRING]]></Declaration>
      <Get Name="Get" Id="{0d53a6f0-66af-4585-b735-0971eb97a602}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AncestorIDs := sAncestorIDs;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f5655c38-0ec4-46ea-a0ed-5b08ec4b6fbd}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sAncestorIDs := AncestorIDs;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Clearing" Id="{6112c2e2-beb3-4b32-8c5f-7d289837fbce}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Clearing]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send clear command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO	
	a_ITF_PackMLBase[nIndex].StateCommand	:=	ePMLCommand_Clear;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Stopped);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="Complete" Id="{be38325c-ec06-4d18-82f0-c5961644db83}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Complete]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Completing" Id="{25f6dadc-f2af-4e8f-bc90-78652fde6245}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Completing]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send complete command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Complete;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Complete);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CreateEvents" Id="{6bbb8cab-407d-45ac-8da1-6eb5ce7199bf}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD CreateEvents : BOOL
VAR_INPUT
END_VAR

VAR
	bCreated1: BOOL;
	bCreated2: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
bCreated1 := F_CreateAllEventsInClass(	p_aAlarms := a_fbPMLAlarms,
							nClassSize := SIZEOF(TC_EVENTS.PMLAlarms),
							pInitEvent := ADR(TC_EVENTS.PMLAlarms.InitReferenceEvent),
							sPrefix := sID_Name);
							
bCreated2 := F_CreateAllEventsInClass(	p_aAlarms := a_fbBaseAlarms,
							nClassSize := SIZEOF(TC_EVENTS.BaseAlarms),
							pInitEvent := ADR(TC_EVENTS.BaseAlarms.InitReferenceEvent),
							sPrefix := sID_Name);							]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicLogic" Id="{71af2bab-1028-44ec-8e3b-3536f0513c8e}" FolderPath="01_ITF_PMLModuleBase\02_Methods\">
      <Declaration><![CDATA[// 
// Cyclic Code
METHOD CyclicLogic]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*********************************************************
//If you are about to write actual machine implementation code, note that implementation code should exist within an implementation machine module block that extends this machine module base!
//*********************************************************

// First loop initialization code is triggered by highest level class
IF NOT bInitialized THEN			//Force initialization code of the object
	initialize();
	bInitialized := TRUE;
END_IF

//  call the subunits
FOR i := 1 TO nNumberOfSubModules DO	
	a_ITF_PackMLBase[i].CyclicLogic();								//Call the main cyclic loop of the subunits 
	a_stPMLSubUnitInfo[i].eState := a_ITF_PackMLBase[i].State;  	//Reflect the state of the subunits to the state machine of the module
END_FOR

FOR i:=1 TO nNumberOfComponents DO
	IF a_ITF_Components[i] <> 0 THEN
		a_ITF_Components[i].CyclicLogic();
	END_IF
END_FOR


// Mode control loop of the module
ModeControl();

// State control loop of the module
StateControl();

HMICommunication();
VISUCommunication();
fbExternalControl();

IF bGlobalSafetyStatus THEN
	IF a_fbBaseAlarms[E_BaseAlarms.PowerNotOK].bRaised THEN
		a_fbBaseAlarms[E_BaseAlarms.PowerNotOK].Clear(0,0);
	END_IF
ELSIF NOT a_fbBaseAlarms[E_BaseAlarms.PowerNotOK].bRaised THEN
		a_fbBaseAlarms[E_BaseAlarms.PowerNotOK].Raise(0);
		eStateCommand := E_PMLCommand.ePMLCommand_Abort;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="Enabled" Id="{a21599c5-6ae5-44f0-9223-afd1d8212c97}" FolderPath="01_ITF_PMLModuleBase\01_Properties\02_Control\">
      <Declaration><![CDATA[PROPERTY Enabled : BOOL]]></Declaration>
      <Get Name="Get" Id="{a6e327b1-41a2-4dd3-a0f8-24a28f9d1b3a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enabled := bEnabled;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{c5f0beb9-4653-47d9-893f-db8a432ad5d6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bEnabled := Enabled;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Execute" Id="{26a49972-0a12-441d-92db-f9f223493eea}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Execute ]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Held" Id="{70dc6f04-1202-4345-ae9f-cc19428dcb1a}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Held ]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="HMICommunication" Id="{0f3b5e33-30dd-42a6-9468-c84dc53cce4a}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD HMICommunication : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Extend this method in extended FBs to communicate specific implementation data

//Process HMI requests
IF stPMLModuleBaseHMI.bIncomingHMIRequest AND NOT stPMLModuleBaseHMI.bHMICommandConfirmation THEN		//If a request has been issued by the HMI, and a previous request has not just E_SequenceState.Finished being processed
	IF stPMLModuleBaseHMI.bHMIControlAvailable THEN		//If the current conditions permit HMI control (Should be determined by the extended application components)
		IF stPMLModuleBaseHMI.bEnableHMIRequest THEN
			bEnabled := TRUE;
			stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
		END_IF
		IF stPMLModuleBaseHMI.bDisableHMIRequest THEN
			bEnabled := FALSE;
			stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
		END_IF
		IF stPMLModuleBaseHMI.bModeCommandHMIRequest THEN
			//KAB eModeCommand := stPMLModuleBaseHMI.eModeCommandHMIValue;
			fbExternalControl.ExternalControlHMI.ModeCommand := stPMLModuleBaseHMI.eModeCommandHMIValue;
			stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
		END_IF
		IF stPMLModuleBaseHMI.bStateCommandHMIRequest THEN
			//KAB eStateCommand := stPMLModuleBaseHMI.eStateCommandHMIValue;
			fbExternalControl.ExternalControlHMI.StateCommand := stPMLModuleBaseHMI.eStateCommandHMIValue;
			stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
		END_IF
	END_IF
	
		//The following commands are always permissible, and are therefore not conditioned with bHMIControlAvailable
	IF stPMLModuleBaseHMI.bActivateStateLogHMIRequest THEN
		bLogStateChanges := TRUE;
		stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
	END_IF
	IF stPMLModuleBaseHMI.bDeactivateStateLogHMIRequest THEN
		bLogStateChanges := FALSE;
		stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
	END_IF
	IF stPMLModuleBaseHMI.bActivateModeLogHMIRequest THEN
		bLogModeChanges := TRUE;
		stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
	END_IF
	IF stPMLModuleBaseHMI.bDeactivateModeLogHMIRequest THEN
		bLogModeChanges := FALSE;
		stPMLModuleBaseHMI.bHMICommandConfirmation := TRUE;	//Confirm that the request has been processed
	END_IF		
END_IF


//Update HMI status info
stPMLModuleBaseHMI.bEnabled := bEnabled;
stPMLModuleBaseHMI.eMode := fbExternalControl.ExternalControlHMI.Mode;		//KAB eMode;
stPMLModuleBaseHMI.nModuleID := nModuleID;
stPMLModuleBaseHMI.sModuleName := sModuleName;
stPMLModuleBaseHMI.eState := fbExternalControl.ExternalControlHMI.State;	//KAB eState;
stPMLModuleBaseHMI.bLogStateChanges := bLogStateChanges;
stPMLModuleBaseHMI.bLogModeChanges := bLogModeChanges;]]></ST>
stPMLModuleBaseHMI.a_sModeNames := a_sModeNames;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Holding" Id="{4c4a9600-833f-4e2c-8c49-79d528d4d25d}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Holding]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send hold command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Hold;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Held);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Idle" Id="{b9ab53ad-9d66-4112-a551-29e98d9dd437}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Idle ]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="initialize" Id="{ce22347d-434e-4e9b-a860-79a350477497}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD initialize
VAR
	i : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[sID_Name := CONCAT(CONCAT(CONCAT(CONCAT(CONCAT('Module ', sAncestorIDs), DINT_TO_STRING(nModuleID)), ' - '), sModuleName), ' '); 	//Creates a utility string for alarms and other messaging that reads (example text) - "Module 10 - Main Casepacker" to be followed by the alarm or message info
CreateEvents();

// Figure out how many Submodules were instantiated - they should be from 1 to X and not skip any indices.
nNumberOfSubModules := 0;
FOR i:=1 TO MAX_NO_OF_SUBMODULES DO
	IF a_ITF_PackMLBase[i] <> 0 THEN
		IF iMasterDataStructure_Adder <> 0 THEN
			iMasterDataStructure_Adder.AddNodeAsChildByName(sNewName := a_ITF_PackMLBase[i].ModuleName, sParentName := ModuleName);
		ELSIF NOT a_fbBaseAlarms[E_BaseAlarms.InvalidInterface].bRaised THEN
			varInfo :=  __VARINFO(iMasterDataStructure_Adder);
			F_RaiseAlarmWithStringParameters(a_fbBaseAlarms[E_BaseAlarms.InvalidInterface], sModuleName, varInfo.Symbol, '');	
		END_IF
		nNumberOfSubModules:=nNumberOfSubModules+1;
		
		a_ITF_PackMLBase[i].AncestorIDs := CONCAT(CONCAT(AncestorIDs, DINT_TO_STRING(ModuleID)), '_');
		a_ITF_PackMLBase[i].MasterDataStructure_Adder 	:= iMasterDataStructure_Adder;
		IF a_ITF_PackMLBase[i].ModuleID = 0 THEN	//If the ID was not manually initialized to anything at declaration, automatically assign it an ID
			a_ITF_PackMLBase[i].ModuleID := i;
		END_IF
	END_IF
END_FOR

nNumberOfComponents := 0;
FOR i:=1 TO MAX_NO_OF_COMPONENTS DO
	IF a_ITF_Components[i] <> 0 THEN

		a_ITF_Components[i].Name := CONCAT(CONCAT(sModuleName,' '),a_ITF_Components[i].Name);	//Add the name of the module as a prefix to the name given in the declaration initialization
		
		IF iMasterDataStructure_Adder <> 0 THEN
			iMasterDataStructure_Adder.AddNodeAsChildByName(sNewName := a_ITF_Components[i].Name, sParentName := ModuleName);
		ELSIF NOT a_fbBaseAlarms[E_BaseAlarms.InvalidInterface].bRaised THEN
			varInfo :=  __VARINFO(iMasterDataStructure_Adder);
			F_RaiseAlarmWithStringParameters(a_fbBaseAlarms[E_BaseAlarms.InvalidInterface], sModuleName, varInfo.Symbol, '');	
		END_IF
		nNumberOfComponents:=nNumberOfComponents+1;
	END_IF
END_FOR

fbExternalControl.Module := THIS^;

// <BASIC INITIALIZATION CODE, DO NOT CHANGE>
// Initialize subunit overview used by state machine
PMLSubUnitInfoRef.ArraySize := SIZEOF(a_stPMLSubUnitInfo);
PMLSubUnitInfoRef.NoOfSubUnits := nNumberOfSubModules;
PMLSubUnitInfoRef.pArray := ADR(a_stPMLSubUnitInfo);
// Point the state machine to the locally defined subunit info 
//fbStateMachine.stSubUnitInfoRef := PMLSubUnitInfoRef;
// <\BASIC INITIALIZATION CODE, DO NOT CHANGE>

// Activate all subunits by default, or change accordingly
FOR i:=1 TO nNumberOfSubModules DO
	a_stPMLSubUnitInfo[i].Active	:= TRUE;					// Follows Main State Machine
END_FOR

FOR i:=1 TO nNumberOfComponents DO
	IF a_ITF_Components[i] <> 0 THEN
		a_ITF_Components[i].Enabled := TRUE;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Property Name="LogModeChanges" Id="{021783ae-5efd-4506-a012-4d08fd7e83f7}" FolderPath="01_ITF_PMLModuleBase\01_Properties\01_Config\">
      <Declaration><![CDATA[PROPERTY LogModeChanges : BOOL]]></Declaration>
      <Get Name="Get" Id="{5e483759-154e-4761-b62a-a7c816d2ebfc}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LogModeChanges:= bLogModeChanges; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f46d3f1b-f363-4efb-8060-ae4e55813e7e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bLogModeChanges := LogModeChanges; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="LogStateChanges" Id="{66903c14-00c7-433b-8055-be34247fabbb}" FolderPath="01_ITF_PMLModuleBase\01_Properties\01_Config\">
      <Declaration><![CDATA[PROPERTY LogStateChanges : BOOL]]></Declaration>
      <Get Name="Get" Id="{e672ec04-4b20-4c25-8d8d-9f55944d549a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LogStateChanges:= bLogStateChanges; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{5c42da14-b508-4ff1-b2f1-616dcf8c8ef8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bLogStateChanges := LogStateChanges; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Mode" Id="{bc2b045c-1313-4030-8d9b-1e43964fed78}" FolderPath="01_ITF_PMLModuleBase\01_Properties\03_Status\">
      <Declaration><![CDATA[PROPERTY Mode : E_PMLUnitMode
]]></Declaration>
      <Get Name="Get" Id="{1dd33fe5-9737-46ae-8efa-b652739a2309}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Mode := eMode;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ModeCommand" Id="{581c69c3-be81-4fff-9cf6-24ab11c559c3}" FolderPath="01_ITF_PMLModuleBase\01_Properties\02_Control\">
      <Declaration><![CDATA[PROPERTY ModeCommand : DINT

]]></Declaration>
      <Set Name="Set" Id="{428042c2-2a29-4c07-9a8f-eebad7e0d1dc}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eModeCommand := ModeCommand;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="ModeControl" Id="{8251b72f-7e35-4652-98c5-3fb000f5552b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PRIVATE ModeControl
VAR
	i					: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//On startup, Mode is invalid, set it to production
IF eMode = E_PMLUnitMode.ePMLUnitMode_Invalid 		THEN 
	fbModeManager.bExecute 		:= TRUE; 
	eModeCommand			 	:= ePMLUNITMODEDEFAULT; 
	eLastModeCommand 			:= eModeCommand;
//If mode is valid and the command has changed, attempt to change modes
ELSIF eModeCommand <> eLastModeCommand 					THEN
	//DONKEY : logging to be implemented
	fbModeManager.bExecute 		:= TRUE;
	eLastModeCommand 			:= eModeCommand;
END_IF

//Handles mode changes based on eModeCommand and the state transition rules defined in the pre-defined protected modes or custom modes
fbModeManager(
	eModeCommand			:= eModeCommand, 
	eState					:= eState, 			
	eModeStatus				=> eMode, 
	bDone					=> , 
	bError					=> , 
	nErrorId				=> 
	);

// Reset mode control command
eModeCommand := E_PMLUnitMode.ePMLUnitMode_Invalid;
fbModeManager.bExecute 		:= FALSE;

//If PackML mode has changed
IF fbModeManager.eModeStatus <> eLastMode  THEN 
	eLastMode := fbModeManager.eModeStatus; 
	//If state change logging is not suppressed
 	IF bLogStateChanges THEN 
		fbPMLModeLogger(
			a_fbPMLAlarms := a_fbPMLAlarms,
			sModulePrefix := sID_Name,
			Mode := fbModeManager.eModeStatus);	
	END_IF	
	// Change SubModules
	FOR i := 1 TO nNumberOfSubModules DO
		a_ITF_PackMLBase[i].ModeCommand := fbModeManager.eModeStatus;		//Call the SetMode loop of the subunits 
	END_FOR

END_IF ]]></ST>
      </Implementation>
    </Method>
    <Property Name="ModuleID" Id="{09c9c517-9d6d-4453-9051-a5bffda96bf8}" FolderPath="01_ITF_PMLModuleBase\01_Properties\01_Config\">
      <Declaration><![CDATA[PROPERTY ModuleID : DINT]]></Declaration>
      <Get Name="Get" Id="{98b97e95-2030-4cdf-9c6a-02fd26d24c96}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ModuleID := nModuleID;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{67ff436c-ee93-483d-b694-d661063e6094}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nModuleID := ModuleID;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="ModuleName" Id="{eaa28a82-9f48-4672-adf0-02d762f98fa4}" FolderPath="01_ITF_PMLModuleBase\01_Properties\01_Config\">
      <Declaration><![CDATA[PROPERTY ModuleName : STRING]]></Declaration>
      <Get Name="Get" Id="{707fcee6-e5c4-4696-bdaf-64e6746ac511}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ModuleName := sModuleName;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{29b514cf-0e85-455d-8f6d-dab417f76dd9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sModuleName := ModuleName;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Resetting" Id="{3807e2e0-6258-4c91-9f18-5b08f4f71847}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Resetting]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send clear/reset command to all sub modules
//As long as this module is in the "Resetting" state, it will attempt to get all modules to Idle by sending abort, clear, and reset commands as appropriate to its children until they do
FOR nIndex := 1 TO nNumberOfSubModules DO
	IF a_ITF_PackMLBase[nIndex].State=ePMLState_Stopped THEN
		a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Reset;
	ELSIF a_ITF_PackMLBase[nIndex].State=ePMLState_Aborted THEN
		a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Clear;
	ELSIF a_ITF_PackMLBase[nIndex].State=ePMLState_Clearing OR a_ITF_PackMLBase[nIndex].State=ePMLState_Stopping 
		OR a_ITF_PackMLBase[nIndex].State=ePMLState_Resetting OR a_ITF_PackMLBase[nIndex].State=ePMLState_Idle THEN
		;
	ELSE
		a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Abort;
	END_IF
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Idle);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Starting" Id="{ebd7ebd1-f8aa-4a46-a1fd-eef86be59683}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Starting]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************
(*
//Perform State tasks here
// Send start command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Start;
END_FOR
*)		//Direct PML state control means we don't want all children immediately going into starting with the parent, only once the parent has deemed the situation appropriate for the child to execute

// All subunits in requested state?
bSubModulesReady	:= TRUE; (*
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Execute);
END_FOR *)
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="State" Id="{d1cab4fd-2e03-4869-8dbf-e461f1addf3b}" FolderPath="01_ITF_PMLModuleBase\01_Properties\03_Status\">
      <Declaration><![CDATA[PROPERTY State : Tc3_PackML_V2.E_PMLState
]]></Declaration>
      <Get Name="Get" Id="{650910fa-121e-4a38-96f8-196357ee8ede}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[State := eState;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="StateCommand" Id="{8c083f47-18a1-4a12-9399-91d5f5b4de80}" FolderPath="01_ITF_PMLModuleBase\01_Properties\02_Control\">
      <Declaration><![CDATA[PROPERTY StateCommand : Tc3_PackML_V2.E_PMLCommand
]]></Declaration>
      <Set Name="Set" Id="{7f7322f3-af6d-41b7-85ea-2b838219d81f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF 	eMode <> E_PMLUnitMode.ePMLUnitMode_Invalid 	AND
 	eState <> E_PMLState.ePMLState_Undefined 			THEN 
	eStateCommand := StateCommand;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="StateComplete" Id="{0144eb9f-b619-4f85-a817-32c0b59111cc}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD StateComplete]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

fbStateMachine.M_StateComplete();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateControl" Id="{adcfbb77-01ec-46bc-88f1-3c657cafd028}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PRIVATE StateControl

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//On startup, state is invalid, set it to default
IF eState = E_PMLState.ePMLState_Undefined 				AND 
	eMode <> E_PMLUnitMode.ePMLUnitMode_Invalid 	THEN 
	eStateCommand 	:= ePMLSTATEDEFAULT; 
END_IF

//If mode is valid and the command has changed, attempt to change modes
IF eStateCommand <> eLastModeCommand 							AND 
	eMode <> E_PMLUnitMode.ePMLUnitMode_Invalid 	THEN
	IF bLogStateChanges THEN 
		//DONKEY : logging to be implemented
		//Simple string insertion, if event class based implementation is desired, follow FB_PMLStateLogger as a template for FB_PMLCommandLogger
		//Logger.logMessage(msg:= CONCAT(ConCAT(deviceIDMessage,' PLC Requests  '), F_CommandStateToString(eStateCommand)));   
		;
	END_IF		
	eLastStateCommand 			:= eStateCommand;
END_IF

//Call PackML state machine	
fbStateMachine(
	eMode				:= eMode, 
	eCommand			:= eStateCommand, 
	stSubUnitInfoRef	:= ,
	stOptions			:= , 
	eState				=> eState, 
	sState 				=> sState, 
	bError				=> , 
	nErrorID			=> );

//If PackML state has changed
IF eState <> eLastState  THEN 
	eLastState := eState; 
	//If state change logging is not suppressed
 	IF bLogStateChanges THEN 
		fbPMLStateLogger(
			a_fbPMLAlarms := a_fbPMLAlarms, 
			sModulePrefix := SID_Name, 
			eState := eState);	
	END_IF	
END_IF 
	
//*********************************************************
//If you are about to write actual machine implementation code, note that implementation code should exist within an implementation equipment module block that extends this equipment module base!
//*********************************************************

// Call appropriate method depending on current PackML state
CASE eState OF
	E_PMLState.ePMLState_Undefined:
		Undefined();
	E_PMLState.ePMLState_Clearing:
		Clearing();
	E_PMLState.ePMLState_Stopped:
		Stopped();
	E_PMLState.ePMLState_Starting:
		Starting();
	E_PMLState.ePMLState_Idle:
		Idle();
	E_PMLState.ePMLState_Suspended:
		Suspended();
	E_PMLState.ePMLState_Execute:
		Execute();
	E_PMLState.ePMLState_Stopping:
		Stopping();
	E_PMLState.ePMLState_Aborting:
		Aborting();
	E_PMLState.ePMLState_Aborted:
		Aborted();
	E_PMLState.ePMLState_Holding:
		Holding();
	E_PMLState.ePMLState_Held:
		Held();
	E_PMLState.ePMLState_Unholding:
		Unholding();
	E_PMLState.ePMLState_Suspending:
		Suspending();
	E_PMLState.ePMLState_Unsuspending:
		Unsuspending();
	E_PMLState.ePMLState_Resetting:   	
		Resetting();
	E_PMLState.ePMLState_Completing:
		Completing();
	E_PMLState.ePMLState_Complete:
		Complete();
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Stopped" Id="{6cf7e365-1763-4f32-a071-b4d38aa6475f}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Stopped]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Stopping" Id="{68934782-9f57-4361-9c27-3ced6fc0b6f9}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Stopping]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send stop command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Stop;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Stopped);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Suspended" Id="{15a0521e-d09e-48c7-a5fb-e09a5fcfb990}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Suspended]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Suspending" Id="{9bd4e4e9-27b1-45dc-a32e-d60e4d2d284c}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Suspending]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send suspend command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Suspend;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Suspended);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Undefined" Id="{e1721cba-4da3-43ce-991b-54764c6d098b}" FolderPath="Methods\02_PrimaryStates\">
      <Declaration><![CDATA[METHOD Undefined ]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Unholding" Id="{d2ff920f-b2b8-44a1-a393-a69ebe202c6f}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Unholding]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send unhold command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Unhold;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Execute);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Unsuspending" Id="{4c1e1471-15af-4f3d-8afa-3204208e7981}" FolderPath="Methods\01_TransitionStates\">
      <Declaration><![CDATA[METHOD Unsuspending]]></Declaration>
      <Implementation>
        <ST><![CDATA[//*************************************************************************************************************************************************************************
//If you are about to write application specific code, note that any such code should exist within the "Application" directory using a Function Block that 'EXTENDS' this base Function Block!
//This particular method's functionality can be overriden in the extended block by creating a method of the same name, with desired functionality therein
//If the functionality of this base module is to be retained, but more functionality is desired, the extended method can contain a SUPER^.ThisMethodName(); call, which will call this code
//*************************************************************************************************************************************************************************

//Perform State tasks here
// Send unsuspend command to all sub modules
FOR nIndex := 1 TO nNumberOfSubModules DO
	a_ITF_PackMLBase[nIndex].StateCommand:=ePMLCommand_Unsuspend;
END_FOR

// All subunits in requested state?
bSubModulesReady	:= TRUE;
FOR nIndex := 1 TO nNumberOfSubModules DO
	bSubModulesReady := bSubModulesReady AND (a_ITF_PackMLBase[nIndex].State = ePMLState_Execute);
END_FOR
IF bSubModulesReady AND (bStateTasksComplete OR bNoStateTasksToComplete) THEN
	bNoStateTasksToComplete := TRUE;
	bStateTasksComplete := FALSE;
	StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="VISUCommunication" Id="{566912f7-1ca8-4177-b0b8-f5f68d6072ff}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD VISUCommunication : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
fbExternalControl.ExternalControlVISU.ClearPressed := stPMLModuleBaseVISU.bClearPressed;
fbExternalControl.ExternalControlVISU.ResetPressed := stPMLModuleBaseVISU.bResetPressed;
fbExternalControl.ExternalControlVISU.StartPressed := stPMLModuleBaseVISU.bStartPressed;
fbExternalControl.ExternalControlVISU.StopPressed := stPMLModuleBaseVISU.bStopPressed;


//Update VISU status info
stPMLModuleBaseVISU.bEnabled := bEnabled;
stPMLModuleBaseVISU.eMode := eMode;		
stPMLModuleBaseVISU.nModuleID := nModuleID;
stPMLModuleBaseVISU.sModuleName := sModuleName;
stPMLModuleBaseVISU.eState := eState;	

// Mode logic here.  Only taking the button from the visualizations
IF stPMLModuleBaseVISU.bProductionPressed AND eMode <> E_PMLUnitMode.ePMLUnitMode_Production THEN
	fbExternalControl.ExternalControlVISU.ModeCommand := E_PMLUnitMode.ePMLUnitMode_Production;
	fbExternalControl.ExternalControlVISU.ModeCommandPulse := TRUE;
END_IF
IF stPMLModuleBaseVISU.bMaintenancePressed AND eMode <> E_PMLUnitMode.ePMLUnitMode_Maintenance THEN
	fbExternalControl.ExternalControlVISU.ModeCommand := E_PMLUnitMode.ePMLUnitMode_Maintenance;
	fbExternalControl.ExternalControlVISU.ModeCommandPulse := TRUE;
END_IF
IF stPMLModuleBaseVISU.bManualPressed AND eMode <> E_PMLUnitMode.ePMLUnitMode_Manual THEN
	fbExternalControl.ExternalControlVISU.ModeCommand := E_PMLUnitMode.ePMLUnitMode_Manual;
	fbExternalControl.ExternalControlVISU.ModeCommandPulse := TRUE;
END_IF

// Extra buttons from Visu here for state changes than the standard 4
// Abort
IF stPMLModuleBaseVISU.bAbortPressed THEN
	CASE eState OF
		ePMLState_Aborted,
		ePMLState_Aborting:
			// DO Nothing
	ELSE
		fbExternalControl.ExternalControlVISU.StateCommand := E_PMLCommand.ePMLCommand_Abort;
		fbExternalControl.ExternalControlVISU.StateCommandPulse := TRUE;	
	END_CASE
END_IF

// Hold
IF stPMLModuleBaseVISU.bHoldPressed THEN
	IF eState = ePMLState_Execute THEN
		fbExternalControl.ExternalControlVISU.StateCommand := E_PMLCommand.ePMLCommand_Hold;
		fbExternalControl.ExternalControlVISU.StateCommandPulse := TRUE;	
	END_IF
END_IF

// unHold
IF stPMLModuleBaseVISU.bUnholdPressed THEN
	IF eState = ePMLState_Held THEN
		fbExternalControl.ExternalControlVISU.StateCommand := E_PMLCommand.ePMLCommand_Unhold;
		fbExternalControl.ExternalControlVISU.StateCommandPulse := TRUE;	
	END_IF
END_IF

// Suspend
IF stPMLModuleBaseVISU.bSuspendPressed THEN
	IF eState = ePMLState_Execute THEN
		fbExternalControl.ExternalControlVISU.StateCommand := E_PMLCommand.ePMLCommand_Suspend;
		fbExternalControl.ExternalControlVISU.StateCommandPulse := TRUE;	
	END_IF
END_IF

// unSuspend
IF stPMLModuleBaseVISU.bUnsuspendPressed THEN
	IF eState = ePMLState_Suspended THEN
		fbExternalControl.ExternalControlVISU.StateCommand := E_PMLCommand.ePMLCommand_Unsuspend;
		fbExternalControl.ExternalControlVISU.StateCommandPulse := TRUE;	
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_PMLModuleBase">
      <LineId Id="582" Count="2" />
      <LineId Id="253" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Aborted">
      <LineId Id="7" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Aborting">
      <LineId Id="109" Count="1" />
      <LineId Id="112" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="86" Count="4" />
      <LineId Id="93" Count="6" />
      <LineId Id="114" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="100" Count="1" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.AncestorIDs.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.AncestorIDs.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Clearing">
      <LineId Id="130" Count="4" />
      <LineId Id="139" Count="0" />
      <LineId Id="105" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="114" Count="5" />
      <LineId Id="135" Count="3" />
      <LineId Id="16" Count="0" />
      <LineId Id="145" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Complete">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Completing">
      <LineId Id="42" Count="5" />
      <LineId Id="21" Count="4" />
      <LineId Id="28" Count="5" />
      <LineId Id="48" Count="3" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.CreateEvents">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="3" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.CyclicLogic">
      <LineId Id="152" Count="31" />
      <LineId Id="5" Count="0" />
      <LineId Id="199" Count="1" />
      <LineId Id="195" Count="2" />
      <LineId Id="201" Count="0" />
      <LineId Id="198" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Enabled.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Enabled.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Execute">
      <LineId Id="24" Count="5" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Held">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.HMICommunication">
      <LineId Id="43" Count="2" />
      <LineId Id="47" Count="0" />
      <LineId Id="132" Count="2" />
      <LineId Id="170" Count="0" />
      <LineId Id="135" Count="2" />
      <LineId Id="169" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="171" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="141" Count="2" />
      <LineId Id="172" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="148" Count="2" />
      <LineId Id="166" Count="0" />
      <LineId Id="152" Count="2" />
      <LineId Id="165" Count="0" />
      <LineId Id="156" Count="2" />
      <LineId Id="164" Count="0" />
      <LineId Id="160" Count="3" />
      <LineId Id="146" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="71" Count="3" />
      <LineId Id="77" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="105" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Holding">
      <LineId Id="124" Count="5" />
      <LineId Id="103" Count="4" />
      <LineId Id="110" Count="5" />
      <LineId Id="130" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Idle">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.initialize">
      <LineId Id="9" Count="0" />
      <LineId Id="17" Count="7" />
      <LineId Id="48" Count="5" />
      <LineId Id="47" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="25" Count="13" />
      <LineId Id="55" Count="4" />
      <LineId Id="54" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.LogModeChanges.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.LogModeChanges.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.LogStateChanges.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.LogStateChanges.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Mode.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModeCommand.Set">
      <LineId Id="7" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModeControl">
      <LineId Id="84" Count="4" />
      <LineId Id="91" Count="1" />
      <LineId Id="110" Count="0" />
      <LineId Id="93" Count="11" />
      <LineId Id="108" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="111" Count="5" />
      <LineId Id="121" Count="0" />
      <LineId Id="124" Count="1" />
      <LineId Id="127" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="131" Count="2" />
      <LineId Id="130" Count="0" />
      <LineId Id="33" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModuleID.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModuleID.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModuleName.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.ModuleName.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Resetting">
      <LineId Id="155" Count="5" />
      <LineId Id="124" Count="1" />
      <LineId Id="154" Count="0" />
      <LineId Id="126" Count="11" />
      <LineId Id="140" Count="5" />
      <LineId Id="161" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Starting">
      <LineId Id="160" Count="5" />
      <LineId Id="139" Count="4" />
      <LineId Id="170" Count="0" />
      <LineId Id="146" Count="5" />
      <LineId Id="166" Count="3" />
      <LineId Id="154" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.State.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.StateCommand.Set">
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.StateComplete">
      <LineId Id="7" Count="5" />
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.StateControl">
      <LineId Id="179" Count="33" />
      <LineId Id="265" Count="2" />
      <LineId Id="216" Count="46" />
      <LineId Id="62" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Stopped">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Stopping">
      <LineId Id="51" Count="5" />
      <LineId Id="30" Count="4" />
      <LineId Id="37" Count="5" />
      <LineId Id="57" Count="3" />
      <LineId Id="45" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Suspended">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Suspending">
      <LineId Id="186" Count="5" />
      <LineId Id="165" Count="4" />
      <LineId Id="172" Count="5" />
      <LineId Id="192" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Undefined">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Unholding">
      <LineId Id="201" Count="5" />
      <LineId Id="180" Count="4" />
      <LineId Id="187" Count="5" />
      <LineId Id="207" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.Unsuspending">
      <LineId Id="214" Count="5" />
      <LineId Id="193" Count="4" />
      <LineId Id="200" Count="5" />
      <LineId Id="220" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_PMLModuleBase.VISUCommunication">
      <LineId Id="6" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="32" Count="2" />
      <LineId Id="29" Count="2" />
      <LineId Id="14" Count="4" />
      <LineId Id="36" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="42" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="46" Count="2" />
      <LineId Id="45" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="51" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="59" Count="2" />
      <LineId Id="55" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="73" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="74" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="77" Count="6" />
      <LineId Id="76" Count="0" />
      <LineId Id="85" Count="6" />
      <LineId Id="84" Count="0" />
      <LineId Id="93" Count="6" />
      <LineId Id="92" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>